#!/usr/bin/env python
"""Generate PPTX template summarizing current project."""
from pptx import Presentation
from pptx.util import Pt
from pathlib import Path

slides_content = [
    ("Cover", [
        "Multi-UAV Grid Coverage: Q-Learning vs QMIX",
        "Presenter:",
        "Date:",
        "Lab/Group:",
        "Add a representative figure (UAV coverage or custom image).",
    ]),
    ("Background & Motivation", [
        "Growing demand for multi-UAV coverage in agriculture, rescue, etc.",
        "Path planning challenges: large state space, obstacles, energy limits.",
        "Reference work: Q-Learning + ANN for farmland coverage.",
        "Goal: introduce QMIX and extend to larger grids, more UAVs, obstacles.",
    ]),
    ("Objectives", [
        "Build a GPU (PyTorch) workflow extending the reference paper.",
        "Compare Q-Learning (global ANN / per-UAV ANN) with QMIX.",
        "Develop metric suite: coverage, productive action rate, steps, energy proxy, collisions, balance.",
        "Deliver reproducible experiments, plots, and a paper draft.",
    ]),
    ("System Overview", [
        "Code structure:",
        "鈥?src/envs: grid environment & obstacles",
        "鈥?src/algos/qlearning & qmix: algorithm implementations",
        "鈥?src/metrics: metric helpers",
        "鈥?scripts: batch runs, log parsing, plotting",
        "Workflow: configs 鈫?run_experiments.py 鈫?logs 鈫?metrics.csv 鈫?plots.",
    ]),
    ("Environment Design", [
        "2D grids (5x5鈥?x7); actions: up/down/left/right.",
        "State encoding: visit map, obstacles, UAV positions, energy proxy.",
        "Obstacles: static with density 0 or 0.10; ensure start reachable.",
        "Rewards: hill-climbing for new cells, penalties for revisits/obstacles, completion bonus.",
    ]),
    ("Algorithms", [
        "Q-Learning: global ANN or per-UAV ANN, replay buffer, target network, epsilon-greedy.",
        "QMIX: agent GRU networks + mixing network via hypernetworks.",
        "Episode replay buffer with optional double-Q.",
        "Environment: RTX 4060, PyTorch 2.7.1/cu126.",
    ]),
    ("Metrics & Tooling", [
        "EpisodeStats tracks steps, coverage, PA, energy proxy, collisions, balance.",
        "metrics.csv generated by scripts/extract_metrics.py.",
        "plots generated by scripts/plot_metrics.py (filter by obstacle/variant).",
        "Batch runner scripts/run_experiments.py.",
    ]),
    ("Experiment Setup", [
        "Maps: 5x5, 6x6, 7x7 (scalable). UAVs: 1 or 2 (plan for 3鈥?).",
        "Obstacle density: 0 and 0.10.",
        "Algorithms: Q-Learning (global/per-UAV), QMIX. Seed = 123.",
        "Training: 50 episodes for Q-Learning, 100 for QMIX (future 200+).",
        "Runtime: Q-Learning ~1鈥? min/setting, QMIX ~3鈥? min/setting.",
    ]),
    ("Results Summary", [
        "Small grids achieve >0.95 coverage; 7x7/obstacle scenarios show QMIX instability.",
        "Productive action rate decreases with map size; adding UAVs improves it.",
        "Average steps grow with map size; more UAVs reduce steps by >40%.",
        "QMIX needs more training or tuning in complex scenarios.",
    ]),
    ("Visualization (Obstacle=0)", [
        "Show coverage/PA/steps vs map size & UAV (obstacle=0).",
        "Observation: algorithms similar on small maps; map=7 shows drop & high variance.",
        "Next: extend training, adjust hyperparameters to stabilize.",
    ]),
    ("Visualization (Obstacle=0.10)", [
        "Show coverage/PA/steps vs map size & UAV (obstacle=0.10).",
        "Coverage around 0.92 (blocked cells); step variance increases.",
        "Per-UAV variant slightly better in some cases but more variance.",
    ]),
    ("Variant Comparison", [
        "Compare global vs per-UAV under different obstacles.",
        "Global ANN yields steadier steps; per-UAV offers higher PA in some settings.",
        "QMIX excels with more UAVs but requires longer training.",
    ]),
    ("Issues & Plans", [
        "QMIX on large/obstacle maps under-trained 鈫?extend episodes, tune learning rate, epsilon schedule.",
        "Add UAV=3/4/6 to highlight centralized training advantage.",
        "Extend metrics: collision rate, energy proxy, coverage curves.",
        "Consider dynamic obstacles or real-map simulation.",
    ]),
    ("Timeline", [
        "Next 1 week: rerun QMIX (longer training, more UAVs); finalize statistics.",
        "Next 2鈥? weeks: write experimental section & discussion; prepare submission package.",
        "Longer term: extend to 3D/real simulations; target SCI Q3 journal.",
    ]),
    ("Summary & Q&A", [
        "Deliverables: codebase, metric pipeline, plots, preliminary conclusions.",
        "Key findings: more UAVs improve coverage; obstacle cases need stronger training; QMIX shows potential.",
        "Next focus: broader experiment matrix, tuning, paper writing.",
        "Questions?",
    ]),
]

output_path = Path("experiments/results/presentation_template.pptx")
output_path.parent.mkdir(parents=True, exist_ok=True)

prs = Presentation()
slide = prs.slides.add_slide(prs.slide_layouts[0])
slide.shapes.title.text = slides_content[0][0]
slide.placeholders[1].text = "\n".join(slides_content[0][1])

for title, bullets in slides_content[1:]:
    slide = prs.slides.add_slide(prs.slide_layouts[1])
    slide.shapes.title.text = title
    tf = slide.placeholders[1].text_frame
    tf.clear()
    for i, bullet in enumerate(bullets):
        if i == 0:
            p = tf.paragraphs[0]
        else:
            p = tf.add_paragraph()
        p.text = bullet
        p.level = 0
        p.font.size = Pt(20)

prs.save(output_path)
print(f"PPTX template saved to {output_path}")
